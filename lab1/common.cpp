// class used to return performance statistics for Prim's algorithm
class PrimStats {
	public:
	int	ckCount;	// changekeyCount from Dheap
	int	suCount;;	// siftupCount from Dheap
	int	sdCount;;	// siftdownCount from Dheap
	int	runtime;;	// total runtim of Prim
	
	/** Set all counters to specified value. */
	void set(int x) { ckCount = suCount = sdCount = runtime = x; }
};

/** Find a minimum spanning tree using Prim's algorithm.
 *  @param wg is a reference to a weighted graph object
 *  @param mstree is a reference to a list used to return
 *  the edges in the mst; it is assumed to be empty when prim is called
 *  @param d is the heap parameter for the heap used by Prim's algorithm.
 *  @param stats is a reference to a PrimStats object in which performance
 *  statistics are returned.
 */
void prim(Wgraph& wg, list<int>& mstree, int d, PrimStats& stats) {

	// Make changes to configure Dheap parameter and
	// return statistics
    // Get the time first
    int t0 = Util::getTime();
	vertex u,v; edge e;
	edge *cheap = new edge[wg.n()+1];
	bool *intree = new bool[wg.n()+1];
    // Create a d heap
	Dheap nheap(wg.n(),d);
    // Initialize all the variables to count the number of steps to 0
    nheap.changeKeyCount = 0;
    nheap.siftupCount = 0;
    nheap.siftdownCount = 0;
    
	for (e = wg.firstAt(1); e != 0; e = wg.nextAt(1,e)) {
		u = wg.mate(1,e); nheap.insert(u,wg.weight(e)); cheap[u] = e;
	}
	intree[1] = true;
	for (u = 2; u <= wg.n(); u++) intree[u] = false;
	while (!nheap.empty()) {
		u = nheap.deletemin();
		intree[u] = true; mstree.push_back(cheap[u]);
		for (e = wg.firstAt(u); e != 0; e = wg.nextAt(u,e)) {
			v = wg.mate(u,e);
			if (nheap.member(v) && wg.weight(e) < nheap.key(v)) {
				nheap.changekey(v,wg.weight(e)); cheap[v] = e;
			} else if (!nheap.member(v) && !intree[v]) {
				nheap.insert(v,wg.weight(e)); cheap[v] = e;
			}
		}
	}
    // Update the statistics
    stats.ckCount = nheap.changeKeyCount;
    stats.suCount = nheap.siftupCount;
    stats.sdCount = nheap.siftdownCount;
    int t1 = Util::getTime();
    stats.runtime = t1-t0;
}

/** Generate a weighted graph on which Prim's algorithm performs poorly.
 *  @param n is the desired number of vertices
 *  @param m is the desired number of edges
 *  @param wg is a reference to a weighted graph object
 *
 *  The graph is generated by first creating edges from vertex 1 to
 *  every other vertex, and then from each vertex u >= 2 to u+1.
 *  Random edges are then added to bring the total to m (so m >= 2*n-3).
 *  Edge weights for edges (u,v) with u<v are set to v-u.
 */
void badcase(int n, int m, Wgraph& wg) {
    vertex u,v; edge e;
    // Creating edges from vertex 1 to every other vertex
    for (u = 2; u <= n; u++) wg.join(1,u);
    // Createing edges from each vertex u >= 2 to u+1.
    for (u = 2; u <= n-1; u++) wg.join(u,u+1);
	// Random edges are then added to bring the total to m (so m >= 2*n-3).
    wg.addEdges(m);
    // Edge weights for edges (u,v) with u<v are set to v-u.
    for (e = wg.first(); e != 0; e = wg.next(e)) {
        u = min(wg.right(e),wg.left(e));
        v = max(wg.right(e),wg.left(e));
        wg.setWeight(e,v-u);
    }
}

/** Generate a weighted graph on which Prim's algorithm performs more poorly.
 *  @param n is the desired number of vertices
 *  @param m is the desired number of edges
 *  @param wg is a reference to a weighted graph object
 *
 *  The graph is generated as in badcase.
 *  If {u,v} is an edge where v=u+1, the weight assigned to {u,v} should be 1
 *  Other edge weights for edges (u,v) with u<v are set to n*(n-u)+(n-v).
 */
void worsecase(int n, int m, Wgraph& wg) {
    vertex u,v; edge e;
    // Creating edges from vertex 1 to every other vertex
    for (u = 2; u <= n; u++) wg.join(1,u);
    // Createing edges from each vertex u >= 2 to u+1.
    for (u = 2; u <= n-1; u++) wg.join(u,u+1);
	// Random edges are then added to bring the total to m (so m >= 2*n-3).
    wg.addEdges(m);
    // If {u,v} is an edge where v=u+1, the weight assigned to {u,v} should be 1
    // Edge weights for edges (u,v) with u<v are set to n*(n-u)+(n-v).
    for (e = wg.first(); e != 0; e = wg.next(e)) {
        u = min(wg.right(e),wg.left(e));
        v = max(wg.right(e),wg.left(e));
        if (v-u == 1)
            wg.setWeight(e,v-u);
        else
            wg.setWeight(e,n*(n-u)+(n-v));
    }
}
